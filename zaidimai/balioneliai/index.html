<!DOCTYPE html>
<html lang="lt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Balionƒóliai ‚Äî Keisti ≈æaidimai</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@600;800&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #0a0e17;
            overflow: hidden;
            font-family: 'Nunito', sans-serif;
            cursor: crosshair;
            user-select: none;
        }

        canvas {
            display: block;
        }

        /* HUD */
        .hud {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1.5rem;
            align-items: center;
            z-index: 10;
            background: rgba(10, 14, 23, 0.85);
            backdrop-filter: blur(8px);
            padding: 0.6rem 1.5rem;
            border-radius: 100px;
            border: 1px solid rgba(217, 119, 6, 0.2);
        }

        .hud-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            color: #9ca3af;
            font-size: 0.9rem;
        }

        .hud-item .val {
            color: #f59e0b;
            font-weight: 800;
            font-size: 1.1rem;
        }

        .back-btn {
            position: fixed;
            top: 1rem;
            left: 1rem;
            z-index: 10;
            color: #9ca3af;
            text-decoration: none;
            font-size: 0.85rem;
            background: rgba(10, 14, 23, 0.85);
            backdrop-filter: blur(8px);
            padding: 0.5rem 1rem;
            border-radius: 100px;
            border: 1px solid rgba(255,255,255,0.08);
            transition: all 0.3s;
        }
        .back-btn:hover { color: #f59e0b; border-color: rgba(217, 119, 6, 0.3); }

        /* Mouse helper hint */
        .mouse-hint {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            color: #4ade80;
            font-size: 0.85rem;
            background: rgba(10, 14, 23, 0.85);
            backdrop-filter: blur(8px);
            padding: 0.5rem 1.2rem;
            border-radius: 100px;
            border: 1px solid rgba(74, 222, 128, 0.2);
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        .mouse-hint.show { opacity: 1; }

        /* Pop effect overlay */
        .pop-text {
            position: fixed;
            pointer-events: none;
            font-weight: 800;
            font-size: 1.5rem;
            z-index: 5;
            animation: popUp 0.8s ease-out forwards;
        }

        @keyframes popUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-60px) scale(1.5); }
        }

        /* Combo display */
        .combo {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            font-weight: 800;
            color: #f59e0b;
            text-shadow: 0 0 40px rgba(245, 158, 11, 0.5);
            z-index: 15;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .combo.show {
            opacity: 1;
            animation: comboPulse 0.5s ease-out;
        }
        @keyframes comboPulse {
            0% { transform: translate(-50%, -50%) scale(0.5); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body>
    <a href="../zaidimai/" class="back-btn">‚Üê ≈Ωaidimai</a>

    <div class="hud">
        <div class="hud-item">üéà <span class="val" id="balloonCount">0</span></div>
        <div class="hud-item">üí• <span class="val" id="popCount">0</span></div>
        <div class="hud-item">üê≠ <span class="val" id="mouseTimer">--</span></div>
    </div>

    <div class="mouse-hint" id="mouseHint">üê≠ Pelytƒó pasiruo≈°usi! Paspausk jƒÖ!</div>
    <div class="combo" id="comboText"></div>

    <canvas id="game"></canvas>

    <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let W, H;
    function resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // ==================== CONFIG ====================
    const COLORS = [
        { name: 'raudona', fill: '#ef4444', glow: 'rgba(239,68,68,0.3)' },
        { name: 'mƒólyna', fill: '#3b82f6', glow: 'rgba(59,130,246,0.3)' },
        { name: '≈æalia', fill: '#22c55e', glow: 'rgba(34,197,94,0.3)' },
        { name: 'geltona', fill: '#eab308', glow: 'rgba(234,179,8,0.3)' },
        { name: 'violetinƒó', fill: '#a855f7', glow: 'rgba(168,85,247,0.3)' },
        { name: 'oran≈æinƒó', fill: '#f97316', glow: 'rgba(249,115,22,0.3)' },
    ];

    const GROW_RATE = 0.15;       // px per frame
    const MAX_RADIUS = 80;
    const SPAWN_INTERVAL = 800;   // ms
    const MAX_BALLOONS = 60;
    const PUSH_FORCE = 0.3;
    const MOUSE_INTERVAL = 45000; // 45 seconds
    const MOUSE_SPEED = 6;
    const MOUSE_DESTROY_RADIUS = 80;

    // ==================== STATE ====================
    let balloons = [];
    let particles = [];
    let popCount = 0;
    let mouseHelper = null;
    let mouseCountdown = MOUSE_INTERVAL / 1000;
    let lastMouseTime = Date.now();
    let mouseAvailable = false;

    // ==================== BALLOON ====================
    class Balloon {
        constructor() {
            this.r = 5;
            this.maxR = 25 + Math.random() * (MAX_RADIUS - 25);
            this.colorIdx = Math.floor(Math.random() * COLORS.length);
            this.color = COLORS[this.colorIdx];
            this.x = 50 + Math.random() * (W - 100);
            this.y = 50 + Math.random() * (H - 100);
            this.vx = 0;
            this.vy = 0;
            this.alive = true;
            this.opacity = 0;
            this.wobble = Math.random() * Math.PI * 2;
            this.wobbleSpeed = 0.02 + Math.random() * 0.02;
            this.string = 20 + Math.random() * 15;
        }

        update() {
            if (!this.alive) return;

            // Grow
            if (this.r < this.maxR) {
                this.r += GROW_RATE;
            }

            // Fade in
            if (this.opacity < 1) this.opacity = Math.min(1, this.opacity + 0.03);

            // Wobble
            this.wobble += this.wobbleSpeed;

            // Apply velocity with damping
            this.x += this.vx;
            this.y += this.vy;
            this.vx *= 0.95;
            this.vy *= 0.95;

            // Wall bounce
            if (this.x - this.r < 0) { this.x = this.r; this.vx = Math.abs(this.vx) * 0.5; }
            if (this.x + this.r > W) { this.x = W - this.r; this.vx = -Math.abs(this.vx) * 0.5; }
            if (this.y - this.r < 0) { this.y = this.r; this.vy = Math.abs(this.vy) * 0.5; }
            if (this.y + this.r > H) { this.y = H - this.r; this.vy = -Math.abs(this.vy) * 0.5; }
        }

        draw() {
            if (!this.alive) return;
            const wobbleX = Math.sin(this.wobble) * 2;
            const wobbleY = Math.cos(this.wobble * 0.7) * 1.5;
            const cx = this.x + wobbleX;
            const cy = this.y + wobbleY;

            ctx.save();
            ctx.globalAlpha = this.opacity;

            // Glow
            ctx.beginPath();
            ctx.arc(cx, cy, this.r + 8, 0, Math.PI * 2);
            ctx.fillStyle = this.color.glow;
            ctx.fill();

            // Body
            const grad = ctx.createRadialGradient(
                cx - this.r * 0.3, cy - this.r * 0.3, this.r * 0.1,
                cx, cy, this.r
            );
            grad.addColorStop(0, '#ffffff40');
            grad.addColorStop(0.3, this.color.fill);
            grad.addColorStop(1, this.color.fill + '99');
            ctx.beginPath();
            ctx.arc(cx, cy, this.r, 0, Math.PI * 2);
            ctx.fillStyle = grad;
            ctx.fill();

            // Shine
            ctx.beginPath();
            ctx.arc(cx - this.r * 0.25, cy - this.r * 0.3, this.r * 0.2, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255,255,255,0.35)';
            ctx.fill();

            // String
            ctx.beginPath();
            ctx.moveTo(cx, cy + this.r);
            ctx.quadraticCurveTo(
                cx + Math.sin(this.wobble * 2) * 8,
                cy + this.r + this.string * 0.6,
                cx + Math.sin(this.wobble) * 4,
                cy + this.r + this.string
            );
            ctx.strokeStyle = 'rgba(255,255,255,0.15)';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.restore();
        }
    }

    // ==================== PARTICLES ====================
    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 8;
            this.vy = (Math.random() - 0.5) * 8 - 3;
            this.r = 2 + Math.random() * 4;
            this.color = color;
            this.life = 1;
            this.decay = 0.02 + Math.random() * 0.02;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.15;
            this.life -= this.decay;
        }
        draw() {
            ctx.save();
            ctx.globalAlpha = this.life;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.restore();
        }
    }

    // ==================== MOUSE HELPER ====================
    class MouseHelper {
        constructor() {
            this.x = -40;
            this.y = H * 0.3 + Math.random() * H * 0.4;
            this.targetY = this.y;
            this.active = true;
            this.clicked = false;
            this.running = false;
            this.runX = 0;
            this.size = 30;
            this.wobble = 0;
            this.trail = [];
        }

        update() {
            if (!this.active) return;

            if (!this.clicked) {
                // Just hovering, waiting to be clicked
                this.wobble += 0.05;
                this.y = this.targetY + Math.sin(this.wobble) * 10;
                // Slowly drift in
                if (this.x < W * 0.85) {
                    this.x += 1;
                }
            } else if (this.running) {
                // Running across screen destroying balloons
                this.x += MOUSE_SPEED;
                this.y += Math.sin(this.x * 0.03) * 3;

                // Trail
                this.trail.push({ x: this.x, y: this.y, life: 1 });

                // Destroy nearby balloons
                for (const b of balloons) {
                    if (!b.alive) continue;
                    const dx = b.x - this.x;
                    const dy = b.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < MOUSE_DESTROY_RADIUS + b.r) {
                        popBalloon(b);
                    }
                }

                if (this.x > W + 50) {
                    this.active = false;
                }
            }

            // Update trail
            this.trail = this.trail.filter(t => {
                t.life -= 0.04;
                return t.life > 0;
            });
        }

        draw() {
            if (!this.active) return;

            // Trail
            for (const t of this.trail) {
                ctx.save();
                ctx.globalAlpha = t.life * 0.3;
                ctx.beginPath();
                ctx.arc(t.x, t.y, 12, 0, Math.PI * 2);
                ctx.fillStyle = '#4ade80';
                ctx.fill();
                ctx.restore();
            }

            ctx.save();
            ctx.translate(this.x, this.y);

            if (this.running) {
                // Running effect - slight tilt
                ctx.rotate(Math.sin(this.x * 0.1) * 0.1);
            }

            // Glow
            ctx.beginPath();
            ctx.arc(0, 0, this.size + 10, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(74, 222, 128, 0.15)';
            ctx.fill();

            // Body
            ctx.font = `${this.size * 1.8}px serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üê≠', 0, 0);

            // Click hint when not yet clicked
            if (!this.clicked && !this.running) {
                const pulse = 0.5 + Math.sin(Date.now() * 0.005) * 0.5;
                ctx.globalAlpha = pulse;
                ctx.beginPath();
                ctx.arc(0, 0, this.size + 20, 0, Math.PI * 2);
                ctx.strokeStyle = '#4ade80';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            ctx.restore();
        }

        isHit(mx, my) {
            const dx = mx - this.x;
            const dy = my - this.y;
            return Math.sqrt(dx * dx + dy * dy) < this.size + 15;
        }

        activate() {
            this.clicked = true;
            this.running = true;
            this.x = -30;
            this.y = H / 2;
        }
    }

    // ==================== PHYSICS ====================
    function resolvePush() {
        for (let i = 0; i < balloons.length; i++) {
            for (let j = i + 1; j < balloons.length; j++) {
                const a = balloons[i];
                const b = balloons[j];
                if (!a.alive || !b.alive) continue;

                const dx = b.x - a.x;
                const dy = b.y - a.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = a.r + b.r;

                if (dist < minDist && dist > 0) {
                    const overlap = (minDist - dist) / 2;
                    const nx = dx / dist;
                    const ny = dy / dist;

                    a.vx -= nx * PUSH_FORCE * overlap;
                    a.vy -= ny * PUSH_FORCE * overlap;
                    b.vx += nx * PUSH_FORCE * overlap;
                    b.vy += ny * PUSH_FORCE * overlap;
                }
            }
        }
    }

    // ==================== POP LOGIC ====================
    function popBalloon(b) {
        if (!b.alive) return;
        b.alive = false;
        popCount++;

        // Spawn particles
        for (let i = 0; i < 12; i++) {
            particles.push(new Particle(b.x, b.y, b.color.fill));
        }
    }

    function findTouchingGroup(clicked) {
        // BFS to find all connected same-color balloons
        const group = [clicked];
        const visited = new Set([balloons.indexOf(clicked)]);
        const queue = [clicked];

        while (queue.length > 0) {
            const curr = queue.shift();
            for (let i = 0; i < balloons.length; i++) {
                if (visited.has(i) || !balloons[i].alive) continue;
                const other = balloons[i];
                if (other.colorIdx !== curr.colorIdx) continue;

                const dx = other.x - curr.x;
                const dy = other.y - curr.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < curr.r + other.r + 5) { // small tolerance
                    visited.add(i);
                    group.push(other);
                    queue.push(other);
                }
            }
        }
        return group;
    }

    function showPopText(x, y, count, color) {
        const el = document.createElement('div');
        el.className = 'pop-text';
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        el.style.color = color;
        el.textContent = count > 1 ? `+${count}` : 'Pop!';
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 800);
    }

    function showCombo(count) {
        if (count < 3) return;
        const el = document.getElementById('comboText');
        const messages = ['Puiku!', 'Nuostabu!', 'Bomba!', '≈†edevras!', 'LEGENDINIS!'];
        const idx = Math.min(Math.floor((count - 3) / 2), messages.length - 1);
        el.textContent = messages[idx] + ' √ó' + count;
        el.classList.add('show');
        setTimeout(() => el.classList.remove('show'), 1200);
    }

    // ==================== CLICK HANDLER ====================
    canvas.addEventListener('click', (e) => {
        const mx = e.clientX;
        const my = e.clientY;

        // Check mouse helper first
        if (mouseHelper && mouseHelper.active && !mouseHelper.clicked) {
            if (mouseHelper.isHit(mx, my)) {
                mouseHelper.activate();
                document.getElementById('mouseHint').classList.remove('show');
                return;
            }
        }

        // Check balloons (reverse order = top first)
        for (let i = balloons.length - 1; i >= 0; i--) {
            const b = balloons[i];
            if (!b.alive) continue;

            const dx = mx - b.x;
            const dy = my - b.y;
            if (Math.sqrt(dx * dx + dy * dy) < b.r) {
                const group = findTouchingGroup(b);
                if (group.length >= 1) {
                    let cx = 0, cy = 0;
                    for (const g of group) {
                        cx += g.x; cy += g.y;
                        popBalloon(g);
                    }
                    cx /= group.length;
                    cy /= group.length;
                    showPopText(cx, cy, group.length, b.color.fill);
                    showCombo(group.length);
                }
                break;
            }
        }
    });

    // ==================== SPAWN ====================
    let lastSpawn = 0;
    function spawnBalloon(time) {
        if (time - lastSpawn > SPAWN_INTERVAL && balloons.filter(b => b.alive).length < MAX_BALLOONS) {
            balloons.push(new Balloon());
            lastSpawn = time;
        }
    }

    // ==================== MOUSE TIMER ====================
    function updateMouseTimer() {
        const elapsed = Date.now() - lastMouseTime;
        const remaining = Math.max(0, Math.ceil((MOUSE_INTERVAL - elapsed) / 1000));
        const timerEl = document.getElementById('mouseTimer');

        if (remaining <= 0 && !mouseAvailable) {
            mouseAvailable = true;
            mouseHelper = new MouseHelper();
            timerEl.textContent = 'üê≠!';
            document.getElementById('mouseHint').classList.add('show');
        } else if (!mouseAvailable) {
            timerEl.textContent = remaining + 's';
        }

        if (mouseHelper && !mouseHelper.active) {
            mouseAvailable = false;
            mouseHelper = null;
            lastMouseTime = Date.now();
            timerEl.textContent = Math.ceil(MOUSE_INTERVAL / 1000) + 's';
            document.getElementById('mouseHint').classList.remove('show');
        }
    }

    // ==================== GAME LOOP ====================
    function loop(time) {
        ctx.clearRect(0, 0, W, H);

        // Background gradient
        const bgGrad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H) * 0.7);
        bgGrad.addColorStop(0, '#111827');
        bgGrad.addColorStop(1, '#0a0e17');
        ctx.fillStyle = bgGrad;
        ctx.fillRect(0, 0, W, H);

        // Spawn
        spawnBalloon(time);

        // Physics
        resolvePush();

        // Update & draw balloons
        for (const b of balloons) {
            b.update();
        }
        for (const b of balloons) {
            b.draw();
        }

        // Clean dead
        balloons = balloons.filter(b => b.alive);

        // Particles
        for (const p of particles) {
            p.update();
            p.draw();
        }
        particles = particles.filter(p => p.life > 0);

        // Mouse helper
        updateMouseTimer();
        if (mouseHelper) {
            mouseHelper.update();
            mouseHelper.draw();
        }

        // HUD
        document.getElementById('balloonCount').textContent = balloons.length;
        document.getElementById('popCount').textContent = popCount;

        requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
    </script>
</body>
</html>
